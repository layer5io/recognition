name: Deploy Preview Site
on:
  workflow_run:
    workflows: ["Build Preview Site"]
    types:
      - completed
    branches:
      - master

# This workflow runs with write permissions from the base repository
permissions:
  contents: write
  pull-requests: write
  actions: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    # Only run if the build was successful and originated from a PR
    if: |
      github.event.workflow_run.conclusion == 'success' &&
      github.event.workflow_run.event == 'pull_request'
    steps:
      - name: Checkout ðŸ›Žï¸
        uses: actions/checkout@v6

      - name: Download artifacts
        uses: actions/github-script@v7
        with:
          script: |
            let allArtifacts = await github.rest.actions.listWorkflowRunArtifacts({
               owner: context.repo.owner,
               repo: context.repo.repo,
               run_id: context.payload.workflow_run.id,
            });
            
            let matchArtifacts = allArtifacts.data.artifacts.filter((artifact) => {
              return artifact.name.match(/^pr-(metadata|public-dir)-/);
            });
            
            if (matchArtifacts.length === 0) {
              core.setFailed('No artifacts found');
              return;
            }
            
            let fs = require('fs');
            for (const artifact of matchArtifacts) {
              let download = await github.rest.actions.downloadArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: artifact.id,
                archive_format: 'zip',
              });
              fs.writeFileSync(`${process.env.GITHUB_WORKSPACE}/${artifact.name}.zip`, Buffer.from(download.data));
            }
      
      - name: Extract artifacts
        run: |
          for zip in *.zip; do
            if [ -f "$zip" ]; then
              mkdir -p "${zip%.zip}"
              unzip -q "$zip" -d "${zip%.zip}"
            fi
          done
      
      - name: Read PR metadata
        id: pr-metadata
        run: |
          # Find the metadata directory
          metadata_dir=$(find . -type d -name "pr-metadata-*" | head -n 1)
          
          if [ -z "$metadata_dir" ]; then
            echo "Error: Could not find PR metadata"
            ls -la
            exit 1
          fi
          
          pr_number=$(cat "$metadata_dir/pr_number")
          pr_action=$(cat "$metadata_dir/pr_action")
          pr_sha=$(cat "$metadata_dir/pr_sha")
          
          echo "pr_number=$pr_number" >> $GITHUB_OUTPUT
          echo "pr_action=$pr_action" >> $GITHUB_OUTPUT
          echo "pr_sha=$pr_sha" >> $GITHUB_OUTPUT
          
          echo "PR Number: $pr_number"
          echo "PR Action: $pr_action"
          echo "PR SHA: $pr_sha"

      - name: Extract site
        run: |
          # Find and extract the public directory zip
          public_artifact=$(find . -type d -name "public-dir-pr-*" | head -n 1)
          
          if [ -z "$public_artifact" ]; then
            echo "Error: Could not find public directory artifact"
            ls -la
            exit 1
          fi
          
          # Find the zip file in the artifact directory
          public_zip=$(find "$public_artifact" -type f -name "*.zip" | head -n 1)
          
          if [ -z "$public_zip" ]; then
            echo "Error: Could not find public directory zip in artifact"
            ls -la "$public_artifact"
            exit 1
          fi
          
          unzip -q "$public_zip"
          
          # Ensure the extracted folder has the static files in a 'public' dir for the action
          if [ -d "public-dir" ] && [ ! -d "public" ]; then
            mv public-dir public
          elif [ ! -d "public" ]; then
            echo "Error: Neither public nor public-dir found after extraction"
            ls -la
            exit 1
          fi

      - name: Deploy Preview
        if: steps.pr-metadata.outputs.pr_action != 'closed'
        uses: rossjrw/pr-preview-action@v1.6.3
        with:
          source-dir: public
          preview-branch: gh-pages
          umbrella-dir: pr-preview
          custom-url: pr-${{ steps.pr-metadata.outputs.pr_number }}
          token: ${{ secrets.GH_ACCESS_TOKEN }}

      - name: Remove Preview on Close
        if: steps.pr-metadata.outputs.pr_action == 'closed'
        uses: rossjrw/pr-preview-action@v1.6.3
        with:
          source-dir: public
          preview-branch: gh-pages
          umbrella-dir: pr-preview
          custom-url: pr-${{ steps.pr-metadata.outputs.pr_number }}
          action: remove
          token: ${{ secrets.GH_ACCESS_TOKEN }}
      
      - name: Comment on PR
        if: steps.pr-metadata.outputs.pr_action != 'closed'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ steps.pr-metadata.outputs.pr_number }};
            const previewUrl = `https://${context.repo.owner}.github.io/${context.repo.repo}/pr-preview/pr-${prNumber}/`;
            
            // Find existing preview comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });
            
            const botComment = comments.data.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Preview deployed')
            );
            
            const commentBody = `ðŸš€ **Preview deployed!**\n\nYou can view the preview at: ${previewUrl}\n\n_This preview will be updated on each push and removed when the PR is closed._`;
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: commentBody
              });
            }
